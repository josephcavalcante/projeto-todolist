<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Relat√≥rio Final - Projeto ToDoList 2.0</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,300;0,400;0,500;0,700;1,400&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;500&display=swap');

        body {
            font-family: 'Roboto', sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 900px;
            margin: 0 auto;
            padding: 40px;
            background-color: #fff;
        }

        h1,
        h2,
        h3,
        h4,
        h5 {
            color: #2c3e50;
            margin-top: 1.5em;
            margin-bottom: 0.5em;
        }

        h1 {
            font-size: 2.2em;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }

        h2 {
            font-size: 1.8em;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
            margin-top: 2em;
        }

        h3 {
            font-size: 1.4em;
            color: #34495e;
            margin-top: 1.5em;
        }

        h4 {
            font-size: 1.1em;
            font-weight: bold;
            color: #555;
            margin-top: 1.2em;
        }

        h5 {
            font-size: 1em;
            font-weight: bold;
            color: #666;
            font-style: italic;
        }

        p {
            margin-bottom: 1em;
            text-align: justify;
        }

        ul {
            margin-bottom: 1em;
            padding-left: 20px;
        }

        li {
            margin-bottom: 0.5em;
        }

        code {
            font-family: 'Fira Code', monospace;
            background-color: #f1f3f5;
            padding: 2px 5px;
            border-radius: 4px;
            font-size: 0.9em;
            color: #c7254e;
        }

        pre {
            background-color: #f6f8fa;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            border: 1px solid #e1e4e8;
            margin-bottom: 1.5em;
        }

        pre code {
            background-color: transparent;
            color: #24292e;
            padding: 0;
            font-size: 0.85em;
            color: #333;
        }

        hr {
            border: 0;
            height: 1px;
            background: #eee;
            margin: 2em 0;
        }

        strong {
            font-weight: 600;
        }

        .header-info {
            margin-bottom: 2em;
        }

        .header-info p {
            margin: 0.2em 0;
        }

        @media print {
            body {
                padding: 0;
                max-width: 100%;
            }

            h1 {
                break-before: page;
            }

            h1:first-of-type {
                break-before: auto;
            }

            pre {
                white-space: pre-wrap;
                word-wrap: break-word;
                break-inside: avoid;
            }

            h2,
            h3 {
                break-after: avoid;
            }
        }
    </style>
</head>

<body>

    <h1>üìÑ Relat√≥rio Final de Arquitetura e Desenvolvimento: ToDoList 2.0</h1>

    <div class="header-info">
        <p><strong>Disciplina:</strong> Padr√µes de Projeto</p>
        <p><strong>Projeto:</strong> Sistema de Gerenciamento de Tarefas (ToDoList)</p>
        <p><strong>Data:</strong> 10/12/2025</p>
        <p><strong>Equipe:</strong> Joseph Nichollas Abreu Cavalcante, Herbert Carvalho dos Santos</p>
    </div>

    <hr>

    <h2>1. Introdu√ß√£o</h2>

    <p>Este relat√≥rio documenta a evolu√ß√£o arquitetural do projeto ToDoList, detalhando a transi√ß√£o de sua vers√£o legada
        (v1.0) para a atual (v2.0). A an√°lise baseia-se na compara√ß√£o direta entre o c√≥digo original (commit
        <code>fc7ce99</code>) e o estado atual, focando nas decis√µes de design iniciais, suas consequ√™ncias negativas e
        as refatora√ß√µes aplicadas para garantir escalabilidade e qualidade.
    </p>

    <hr>

    <h2>2. Decis√µes de Design "Question√°veis" (An√°lise do Legado v1.0)</h2>

    <p>Ao revisar o c√≥digo-fonte da primeira vers√£o entregue (<code>fc7ce99</code>), identificamos padr√µes que limitavam
        severamente a evolu√ß√£o do software.</p>

    <h3>‚ùå 2.1. A Serializa√ß√£o Monol√≠tica (<code>controle.ManipuladorDeTarefas</code>)</h3>
    <ul>
        <li><strong>A Decis√£o:</strong> A classe <code>ManipuladorDeTarefas</code> implementava
            <code>Serializable</code> e guardava todas as tarefas em uma <code>ArrayList</code> em mem√≥ria. Para
            persistir, grav√°vamos o objeto inteiro.
        </li>
        <li><strong>O C√≥digo Legado (v1.0):</strong></li>
    </ul>

    <pre><code>// controle/ManipuladorDeTarefas.java
public class ManipuladorDeTarefas implements Serializable {
    private List&lt;Tarefa&gt; listaTarefas;

    public void cadastrarTarefa(String titulo, String descricao, String deadlineStr, int prioridade) throws Exception {
            try {
                // convers√£o DD/MM/AAAA para LocalDate
                String[] partesData = deadlineStr.split("/");
                int dia = Integer.parseInt(partesData[0]);
                int mes = Integer.parseInt(partesData[1]);
                int ano = Integer.parseInt(partesData[2]);
                
                LocalDate prazoFinal = LocalDate.of(ano, mes, dia);
                LocalDate dataAtual = LocalDate.now();
                
                Tarefa novaTarefa = new Tarefa(titulo, descricao, dataAtual, prazoFinal, prioridade);
                adicionarTarefa(novaTarefa);
            } catch (Exception erro) {
                throw new Exception("Data inv√°lida. Use o formato DD/MM/AAAA");
            }
        }
    
    public List&lt;Tarefa&gt; listarTarefasCriticas() {
        LocalDate dataAtual = LocalDate.now();
        return listaTarefas.stream()
            .filter(tarefa -&gt; tarefa.getDeadline().minusDays(tarefa.getPrioridade()).isBefore(dataAtual))
            .collect(Collectors.toList());
    }
}</code></pre>

    <ul>
        <li><strong>Por que foi ruim:</strong>
            <ul>
                <li><strong>Mon√≥lito de Dados:</strong> Se tiv√©ssemos 1 milh√£o de tarefas, precis√°vamos carregar 1
                    milh√£o de objetos na RAM para editar um √∫nico t√≠tulo.</li>
                <li><strong>Viola√ß√£o de SRP:</strong> A classe sabia gerenciar a lista, filtrar dados e at√© fazer
                    parsing de String para Data (<code>DD/MM/AAAA</code>).</li>
                <li><strong>Fragilidade de Vers√£o:</strong> Como a classe implementava <code>Serializable</code>,
                    qualquer mudan√ßa no c√≥digo (ex: mudar nome de vari√°vel) impedia a leitura dos arquivos salvos
                    anteriormente.</li>
            </ul>
        </li>
    </ul>

    <h3>‚ùå 2.2. A "God Class" (<code>controle.ToDoList</code>) com Estado Global</h3>
    <ul>
        <li><strong>A Decis√£o:</strong> A classe <code>ToDoList</code> acumulava responsabilidades de Controller, Facade
            e Persist√™ncia. Pior ainda, ela mantinha o estado da aplica√ß√£o (<code>usuarioAtual</code> e
            <code>gerenciadorTarefas</code>) em mem√≥ria.
        </li>
        <li><strong>O C√≥digo Legado (v1.0):</strong></li>
    </ul>

    <pre><code>public class ToDoList {
    private ManipuladorDeTarefas gerenciadorTarefas;
    private Persistencia salvaDados;
    private Usuario usuarioAtual;
    private TarefaService serviceTarefas;
    private SubtarefaService serviceSubs;
    private static final String ARQUIVO_DADOS = "todolist.dat"; // arquivo onde salva

    // construtor - inicializa tudo
    public ToDoList() {
        this.gerenciadorTarefas = new ManipuladorDeTarefas();
        this.salvaDados = new Persistencia();
        this.usuarioAtual = new Usuario("Usu√°rio", "projetopoo00@gmail.com"); // email fixo
        
        // tenta carregar dados salvos
        carregarDados();
        
        // cria os services
        this.serviceTarefas = new TarefaService(gerenciadorTarefas);
        this.serviceSubs = new SubtarefaService(gerenciadorTarefas, serviceTarefas);
    }

    // carrega os dados do arquivo
    private void carregarDados() {
        try {
            ManipuladorDeTarefas dadosCarregados = salvaDados.carregarManipulador(ARQUIVO_DADOS);
            if (dadosCarregados != null) {
                this.gerenciadorTarefas = dadosCarregados; // substitui o vazio
                // se tem usuario salvo, usa ele
                if (dadosCarregados.getUsuario() != null) {
                    this.usuarioAtual = dadosCarregados.getUsuario();
                }
            }
        } catch (Exception erro) {
            System.out.println("Arquivo de dados n√£o encontrado. Iniciando com dados vazios.");
        }
}</code></pre>

    <ul>
        <li><strong>Por que foi ruim:</strong>
            <ul>
                <li><strong>Acoplamento Temporal e de Sess√£o:</strong> A inst√¢ncia de<code>ToDoList</code> "sabia" quem
                    estava
                    logado. Passar essa inst√¢ncia de uma tela para outra significava carregar todo o estado da sess√£o
                    junto. Se o sistema reiniciasse, o login era perdido instantaneamente.</li>
                <li><strong>Acoplamento por Instancia√ß√£o Concreta:</strong> A classe violava o princ√≠pio de Invers√£o de
                    Depend√™ncia (DIP) ao instanciar manualmente suas depend√™ncias com <code>new</code> (ex: <code>this.salvaDados = new
                    Persistencia()</code>). Isso impedia a troca de implementa√ß√µes (como substituir a persist√™ncia em
                    arquivo
                    por banco de dados) sem reescrever a classe principal.</li>
            </ul>
        </li>
    </ul>

    <h3>‚ùå 2.3. Persist√™ncia Bin√°ria Fr√°gil (<code>persistencia.Persistencia</code>)</h3>
    <ul>
        <li><strong>A Decis√£o:</strong> A classe <code>Persistencia</code> encapsulava a escrita direta de objetos Java
            em disco.</li>
        <li><strong>O C√≥digo Legado (v1.0):</strong></li>
    </ul>

    <pre><code>public class Persistencia {

    // grava√ß√£o do manipulador em arquivo
    public void salvarManipulador(ManipuladorDeTarefas manipulador, String nomeArquivo) {
        try (ObjectOutputStream gravador = new ObjectOutputStream(new FileOutputStream(nomeArquivo))) {
            gravador.writeObject(manipulador);
        } catch (IOException erro) {
            erro.printStackTrace();
        }
    }

    // carregamento do manipulador do arquivo
    public ManipuladorDeTarefas carregarManipulador(String nomeArquivo) {
        try (ObjectInputStream leitor = new ObjectInputStream(new FileInputStream(nomeArquivo))) {
            return (ManipuladorDeTarefas) leitor.readObject();
        } catch (IOException | ClassNotFoundException ex) {
            return null; // arquivo inexistente ou corrompido
        }
    }
} </code></pre>

    <ul>
        <li><strong>Por que foi ruim:</strong>
            <ul>
                <li><strong>Fragilidade Extrema:</strong> Qualquer altera√ß√£o simples nas classes <code>Tarefa</code> ou
                    <code>Usuario</code> (como adicionar um campo novo) alterava o <code>serialVersionUID</code>,
                    causando <code>InvalidClassException</code>. Isso obrigava a limpar o banco de dados a cada deploy.
                </li>
                <li><strong>Escalabilidade Zero:</strong> Ler e gravar o arquivo inteiro a cada
                    <code>adicionarTarefa()</code> causava lentid√£o exponencial.
                </li>
            </ul>
        </li>
    </ul>

    <hr>

    <h2>3. Refatora√ß√µes e Bons Princ√≠pios (Clean Core & SOLID)</h2>

    <p>A vers√£o 2.0 foi reescrita focando em desacoplamento e estabilidade.</p>

    <h3>‚úÖ 3.1. Invers√£o de Controle e Persist√™ncia Poliglota</h3>
    <p>Abandonamos o arquivo bin√°rio e adotamos JPA (Hibernate).</p>

    <ul>
        <li><strong>Refatora√ß√£o:</strong> Substitu√≠mos o m√©todo <code>salvarDados()</code> direto na
            <code>ToDoList</code> por Reposit√≥rios injetados.
        </li>
        <li><strong>Impacto Positivo:</strong>
            <ul>
                <li><strong>Independ√™ncia de Dados:</strong> O <code>TarefaService</code> agora apenas chama
                    <code>repositorio.salvar(tarefa)</code>. Ele n√£o sabe se est√° salvando no Postgres ou no MongoDB
                    (Subtarefas).
                </li>
                <li><strong>Seguran√ßa de Dados:</strong> Alterar a classe <code>Tarefa</code> n√£o corrompe o banco, pois
                    o Hibernate gerencia a migra√ß√£o do Schema.</li>
            </ul>
        </li>
    </ul>

    <h4>C√≥digo Antes (Legado):</h4>
    <pre><code>// ToDoList.java v1.0
public void removerTarefa(Tarefa tarefa) {
    gerenciadorTarefas.removerTarefa(tarefa);
    salvarDados(); // Grava√ß√£o em arquivo for√ßada
}</code></pre>

    <h4>C√≥digo Depois (v2.0):</h4>
    <pre><code>// TarefaService.java v2.0
public boolean excluir(String titulo, Usuario usuario) {
    Tarefa tarefa = buscarPorTitulo(titulo, usuario);
    if (tarefa != null) {
        repositorio.remover(tarefa); // Delega para o banco SQL
        return true;
    }
    return false;
}</code></pre>

    <h3>‚úÖ 3.2. Segrega√ß√£o de Valida√ß√£o (SRP)</h3>
    <p>Retiramos regras como "T√≠tulo n√£o pode ser vazio" de dentro do Controller/View e criamos classes especialistas.
    </p>
    <ul>
        <li><strong>O que fizemos:</strong> Criamos o pacote <code>validadores</code> (<code>ValidadorTarefa</code>,
            <code>ValidadorEvento</code>).
        </li>
        <li><strong>Benef√≠cio:</strong> Se a regra de valida√ß√£o mudar (ex: t√≠tulo agora precisa de 5 caracteres),
            alteramos apenas o <code>Validador</code>, sem risco de quebrar a persist√™ncia ou a tela.</li>
    </ul>

    <h3>‚úÖ 3.3. Centraliza√ß√£o da Cria√ß√£o (Simple Factory)</h3>
    <p>Utilizamos uma Factory para isolar a complexidade de instanciar objetos e suas depend√™ncias.</p>
    <ul>
        <li><strong>Motiva√ß√£o:</strong> Criar um <code>TarefaService</code> exige instanciar um <code>Validador</code>,
            um <code>Repository</code> SQL, um <code>Repository</code> Redis (Cache) e um <code>Proxy</code>. Espalhar
            essa l√≥gica pelo sistema violaria DRY e aumentaria o acoplamento.</li>
        <li><strong>O C√≥digo:</strong></li>
    </ul>
    <pre><code>public static ITarefaService criarTarefaService() {
    // 1. Cria os componentes crus
    ITarefaRepository sqlRepo = new TarefaRepository();
    TarefaCacheRepository redisRepo = new TarefaCacheRepository();

    // 2. Envolve o SQL com o Proxy de Cache
    ITarefaRepository repoComCache = new TarefaRepositoryProxy(sqlRepo, redisRepo);

    IValidadorTarefa validador = new ValidadorTarefa();

    // 3. Entrega o Proxy para o Service (O Service nem sabe que existe cache!)
    return new TarefaService(repoComCache, validador);
}</code></pre>

    <h3>‚úÖ 3.4. Segrega√ß√£o de Interface (ISP)</h3>
    <p>Dividimos interfaces gigantes em menores e espec√≠ficas.</p>
    <ul>
        <li><strong>Exemplo:</strong> Em vez de uma interface <code>ISistema</code> com 50 m√©todos, temos
            <code>ITarefaService</code>, <code>ISubtarefaService</code>, <code>IUsuarioService</code>.
        </li>
        <li><strong>Ganho:</strong> A classe <code>SubtarefaController</code> s√≥ precisa conhecer
            <code>ISubtarefaService</code>. Ela n√£o tem acesso a m√©todos de Login ou Eventos, respeitando o princ√≠pio do
            menor privil√©gio.
        </li>
    </ul>

    <hr>

    <h2>4. Aplica√ß√£o de Padr√µes de Projeto (GoF)</h2>

    <p>Design Patterns foram aplicados onde havia dor real no desenvolvimento.</p>

    <h3>üß© 4.1. Template Method (Relat√≥rios)</h3>

    <ul>
        <li><strong>Motiva√ß√£o:</strong> No commit <code>947d12e</code>, o <code>GeradorDeRelatorios</code> duplicava a
            l√≥gica de abrir/fechar streams para PDF e CSV.</li>
        <li><strong>Solu√ß√£o:</strong> <code>RelatorioTemplate</code> define o fluxo <code>final gerarRelatorio()</code>.
        </li>
    </ul>

    <h4>C√≥digo Antes (1.0):</h4>
    <pre><code>public class GeradorDeRelatorios {
    
    // gera√ß√£o de relat√≥rio PDF di√°rio
    public static void gerarRelatorioPDF(List&lt;Tarefa&gt; tarefas, LocalDate data) {
        Document documentoPDF = new Document();
        try {
            // configura√ß√£o do arquivo PDF
            PdfWriter.getInstance(documentoPDF, new FileOutputStream("relatorio.pdf"));
            documentoPDF.open();
            documentoPDF.add(new Paragraph("Relat√≥rio de Tarefas do dia: " + data));
            documentoPDF.add(new Paragraph(" "));

            // verifica√ß√£o de exist√™ncia de tarefas
            if (tarefas.isEmpty()) {
                documentoPDF.add(new Paragraph("Nenhuma tarefa encontrada para este dia."));
            } else {
                // itera√ß√£o sobre as tarefas
                for (Tarefa item : tarefas) {
                    documentoPDF.add(new Paragraph("T√≠tulo: " + item.getTitulo()));
                    documentoPDF.add(new Paragraph("Descri√ß√£o: " + item.getDescricao()));
                    documentoPDF.add(new Paragraph("Deadline: " + item.getDeadline()));
                    documentoPDF.add(new Paragraph("Prioridade: " + item.getPrioridade()));
                    documentoPDF.add(new Paragraph("Percentual: " + item.getPercentual() + "%"));
                    documentoPDF.add(new Paragraph(" "));
                }
            }
        } catch (DocumentException | IOException erro) {
            erro.printStackTrace();
        } finally {
            documentoPDF.close();
        }
    }

    // cria√ß√£o de planilha Excel (formato CSV)
    public static void gerarRelatorioExcel(List&lt;Tarefa&gt; tarefas, int mes, int ano) {
        // implementa√ß√£o simples usando CSV
        try (FileOutputStream arquivoSaida = new FileOutputStream("relatorio_mensal.csv")) {
            StringBuilder conteudoCSV = new StringBuilder();
            conteudoCSV.append("T√≠tulo,Descri√ß√£o,Deadline,Prioridade,Percentual,Status\n");
            
            // processamento de cada tarefa
            for (Tarefa itemTarefa : tarefas) {
                String situacao = itemTarefa.getPercentual() >= 100.0 ? "CONCLU√çDA" : "PENDENTE"; // 100.0 explicito
                conteudoCSV.append(String.format("\"%s\",\"%s\",%s,%d,%.1f,%s\n",
                    itemTarefa.getTitulo(),
                    itemTarefa.getDescricao(),
                    itemTarefa.getDeadline(),
                    itemTarefa.getPrioridade(),
                    itemTarefa.getPercentual(),
                    situacao));
            }
            
            // grava√ß√£o do conte√∫do
            arquivoSaida.write(conteudoCSV.toString().getBytes("UTF-8"));
        } catch (IOException erro) {
            erro.printStackTrace();
        }
    }
} </code></pre>

    <h4>C√≥digo Depois (Padr√£o Aplicado):</h4>
    <h5>Gerador De Relatorios</h5>
    <pre><code>public class GeradorDeRelatorios implements IRelatorioService {

    @Override
    public boolean gerarPDF(List&lt;Tarefa&gt; tarefas, LocalDate data) {
        RelatorioTemplate relatorio = new RelatorioPDF(data);
        return relatorio.gerarRelatorio(tarefas, "relatorio.pdf");
    }</code></pre>
    <h5>Relatorio Template</h5>
    <pre><code>public abstract class RelatorioTemplate {
    public final boolean gerarRelatorio(List&lt;Tarefa&gt; tarefas, String caminhoArquivo) {
        try {
            abrirArquivo(caminhoArquivo);
            escreverCabecalho();
            if (tarefas.isEmpty()) {
                escreverCorpoVazio();
            } else {
                for (Tarefa tarefa : tarefas) {
                    escreverTarefa(tarefa);
                }
            }
            escreverRodape();
            fecharArquivo();
            System.out.println("Relat√≥rio gerado em: " + caminhoArquivo);
            return true;
        } catch (Exception e) {
            System.err.println("Erro ao gerar relat√≥rio: " + e.getMessage());
            tratarErro(e);
            return false;
        }
    }

    // Hooks 
    protected abstract void abrirArquivo(String caminho) throws Exception;

    protected abstract void escreverCabecalho() throws Exception;

    protected abstract void escreverTarefa(Tarefa tarefa) throws Exception;

    protected abstract void fecharArquivo() throws Exception;
}</code></pre>
    <h5>Relatorio PDF</h5>
    <pre><code>public class RelatorioPDF extends RelatorioTemplate {
    private Document documentoPDF;
    private LocalDate dataRelatorio;

    public RelatorioPDF(LocalDate data) {
        this.dataRelatorio = data;
    }

    protected void abrirArquivo(String caminho) throws Exception {
        documentoPDF = new Document();
        PdfWriter.getInstance(documentoPDF, new FileOutputStream(caminho));
        documentoPDF.open();
    }

    protected void escreverCabecalho() throws Exception {
        documentoPDF.add(new Paragraph("Relat√≥rio de Tarefas do dia: " + dataRelatorio));
        documentoPDF.add(new Paragraph(" ")); // Linha em branco
    }

    protected void escreverTarefa(Tarefa tarefa) throws Exception {
        documentoPDF.add(new Paragraph("T√≠tulo: " + tarefa.getTitulo()));
        documentoPDF.add(new Paragraph("Descri√ß√£o: " + tarefa.getDescricao()));
        documentoPDF.add(new Paragraph("Deadline: " + tarefa.getDeadline()));
        documentoPDF.add(new Paragraph("Prioridade: " + tarefa.getPrioridade()));
        documentoPDF.add(new Paragraph("Percentual: " + tarefa.getPercentual() + "%"));
        documentoPDF.add(new Paragraph("--------------------------------------------------"));
    }

    protected void fecharArquivo() throws Exception {
        if (documentoPDF != null) {
            documentoPDF.close();
        }
    }
}
</code></pre>

    <hr>

    <h3>üö¶ 4.2. Strategy (Estrat√©gias de Filtro e Ordena√ß√£o)</h3>

    <ul>
        <li><strong>Motiva√ß√£o:</strong> O <code>ManipuladorDeTarefas</code> (v1.0) tinha m√©todos r√≠gidos como
            <code>listarTarefasPorData</code> e <code>listarTarefasCriticas</code>. Se quis√©ssemos um novo filtro,
            ter√≠amos que modificar a classe principal.
        </li>
        <li><strong>Solu√ß√£o:</strong> Interface <code>IFiltroStrategy</code>.</li>
    </ul>

    <h4>C√≥digo Antes (Legado):</h4>
    <pre><code>public class ManipuladorDeTarefas implements Serializable {
    // filtragem de tarefas por data espec√≠fica
    public List&lt;Tarefa&gt; listarTarefasPorData(LocalDate data) {
        return listaTarefas.stream()
                .filter(tarefa -&gt; tarefa.getDeadline().equals(data))
                .collect(Collectors.toList());
    }
}    </code></pre>

    <h4>C√≥digo Depois (Strategy):</h4>

    <h5>Interface Filtro :</h5>
    <pre><code>public interface IFiltroStrategy {
    List&lt;Tarefa&gt; filtrar(List&lt;Tarefa&gt; tarefas);
}</code></pre>

    <h5>Filtro por Data :</h5>
    <pre><code>public class FiltroPorDataStrategy implements IFiltroStrategy {
    private final LocalDate dataAlvo;

    public FiltroPorDataStrategy(LocalDate dataAlvo) {
        this.dataAlvo = dataAlvo;
    }

    public List&lt;Tarefa&gt; filtrar(List&lt;Tarefa&gt; tarefas) {
        if (dataAlvo == null) {
            return tarefas; // Se data √© null, retorna tudo (ou podia retornar vazio)
        }
        return tarefas.stream()
                .filter(t -&gt; t.getDeadline().equals(dataAlvo))
                .collect(Collectors.toList());
    }
}</code></pre>

    <h5>Facade :</h5>
    <pre><code>public class ToDoList {
    public List&lt;Tarefa&gt; listarTarefasPorData(LocalDate data) {
        Usuario usuario = usuarioController.obterUsuario();
        if (usuario != null) {
            return tarefaController.listar(new FiltroPorDataStrategy(data), usuario);
        }
        return Collections.emptyList();
    }
}</code></pre>

    <h5>Tarefa Service :</h5>
    <pre><code>public class TarefaService implements ITarefaService {
    public List&lt;Tarefa&gt; listar(interfaces.strategies.IFiltroStrategy filtro, Usuario usuario) {
        if (usuario == null) return new ArrayList<>();

        List&lt;Tarefa&gt; todasTarefas = repositorio.listarPorUsuario(usuario);

        if (todasTarefas == null) {
            todasTarefas = new ArrayList<>();
        }

        // Aplica o filtro (Strategy) em mem√≥ria sobre os dados retornados
        return filtro.filtrar(todasTarefas);
    }
}</code></pre>

    <ul>
        <li><strong>Consequ√™ncia:</strong> Adicionar um filtro "Por Nome" agora envolve apenas criar uma nova classe,
            sem risco de quebrar os filtros existentes (OCP).</li>
    </ul>

    <hr>

    <h3>üèØ 4.3. Facade (<code>ToDoList</code> Refatorado)</h3>
    <ul>
        <li><strong>Problema:</strong> A classe <code>ToDoList</code>era uma "God Class" cl√°ssica: ela fazia tudo
            (Carregava arquivo, gerenciava usu√°rio, criava objetos, tratava exce√ß√µes).</li>
        <li><strong>Solu√ß√£o:</strong> A classe <code>ToDoList</code> agora √© uma Fachada Real. Ela n√£o tem regra de
            neg√≥cio, nem estado global, nem persist√™ncia direta. Ela apenas delega e organiza o acesso aos subsistemas.
        </li>
    </ul>

    <h4>v1.0 (God Class) :</h4>
    <pre><code>    public class ToDoList {
        private ManipuladorDeTarefas gerenciadorTarefas;
        private Persistencia salvaDados;
        private Usuario usuarioAtual;
        private TarefaService serviceTarefas;
        private SubtarefaService serviceSubs;
        private static final String ARQUIVO_DADOS = "todolist.dat"; // arquivo onde salva

        // construtor - inicializa tudo
        public ToDoList() {
            this.gerenciadorTarefas = new ManipuladorDeTarefas();
            this.salvaDados = new Persistencia();
            this.usuarioAtual = new Usuario("Usu√°rio", "projetopoo00@gmail.com"); // email fixo
            
            // tenta carregar dados salvos
            carregarDados();
            
            // cria os services
            this.serviceTarefas = new TarefaService(gerenciadorTarefas);
            this.serviceSubs = new SubtarefaService(gerenciadorTarefas, serviceTarefas);
        }

        // carrega os dados do arquivo
        private void carregarDados() {
            try {
                ManipuladorDeTarefas dadosCarregados = salvaDados.carregarManipulador(ARQUIVO_DADOS);
                if (dadosCarregados != null) {
                    this.gerenciadorTarefas = dadosCarregados; // substitui o vazio
                    // se tem usuario salvo, usa ele
                    if (dadosCarregados.getUsuario() != null) {
                        this.usuarioAtual = dadosCarregados.getUsuario();
                    }
                }
            } catch (Exception erro) {
                System.out.println("Arquivo de dados n√£o encontrado. Iniciando com dados vazios.");
            }
    }
 </code></pre>

    <h4>v2.0 Facade :</h4>
    <p>N√£o tem estado. Apenas encaminha pro <code>controller</code></p>
    <pre><code>public class ToDoList {
    public boolean login(String email, String senha) {
        return usuarioController.login(email, senha);
    }

    public boolean cadastrarUsuario(String nome, String email, String senha) {
        return usuarioController.cadastrar(nome, email, senha);
    }

    public void logout() {
        usuarioController.logout();
    }

    public boolean isUsuarioLogado() {
        return usuarioController.isLogado();
    }

    public Usuario obterUsuario() {
        return usuarioController.obterUsuario();
    }
 </code></pre>

    <hr>

    <h3>üì° 4.4. Observer (Notifica√ß√µes)</h3>

    <ul>
        <li><strong>Problema:</strong> Para beneficiar a escalabilidade, tarefa como ponto mais importante do app,
            precisava de uma maneira padronizada e f√°cil de avisar aos interessados quando uma tarefa √© alterada.</li>
        <li><strong>Solu√ß√£o:</strong> O <code>TarefaService</code> notifica observadores registrados.</li>
    </ul>

    <h4>C√≥digo:</h4>
    <h5>Interface Observer:</h5>
    <pre><code>public interface IObserver {
    void atualizar(Object mensagem);
}
</code></pre>
    <h5>Interface Subject:</h5>
    <pre><code>public interface ISubject {
    void adicionarObservador(IObserver observer);
    void removerObservador(IObserver observer);
    void notificarObservadores(Object mensagem);
}
</code></pre>
    <h5>Subject Concreto (Tarefa Serice):</h5>
    <pre><code>public class TarefaService implements ITarefaService, ISubject {
    private List&lt;interfaces.observer.IObserver&gt; observadores = new ArrayList&lt;&gt;();

    public void adicionarObservador(interfaces.observer.IObserver observer) {
        observadores.add(observer);
    }
    public void removerObservador(interfaces.observer.IObserver observer) {
        observadores.remove(observer);
    }
    public void notificarObservadores(Object mensagem) {
        for (interfaces.observer.IObserver observer : observadores) {
            observer.atualizar(mensagem);
        }
    }
    public void atualizarPercentual(Long idTarefa, double novoPercentual) {
        try {
            Tarefa tarefa = repositorio.buscarPorId(idTarefa);
            if (tarefa != null) {
                tarefa.setPercentual(novoPercentual);
                repositorio.salvar(tarefa);
                notificarObservadores("Tarefa atualizada: " + tarefa.getTitulo());
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }    
}
</code></pre>
    <h5>Observer Concreto (TelaListarTarefas):</h5>
    <pre><code>public class TelaListarTarefas extends JPanel implements IObserver {
    public void removeNotify() {
        sistema.getTarefaService().removerObservador(this);
        super.removeNotify();
    }
    public void atualizar(Object mensagem) {
        SwingUtilities.invokeLater(() -&gt; {
            carregarTarefas(this.dataFiltro);
        });
    }
</code></pre>

    <hr>

    <h3>üõ°Ô∏è 4.5. Proxy (Cache Transparente)</h3>

    <ul>
        <li><strong>Problema:</strong> Adicionar cache no Service sujava a regra de neg√≥cio com l√≥gica de infraestrutura
            (Redis).</li>
        <li><strong>Solu√ß√£o:</strong> O <code>TarefaRepositoryProxy</code> finge ser um reposit√≥rio comum, mas gerencia
            o cache, pois envolve o reposit√≥rio real e intercepta as chamadas. Service nem sabe que existe cache, ele
            acredita que est√° falando com o banco de dados.</li>
    </ul>

    <h4>C√≥digo antigo:</h4>
    <pre><code>public class TarefaService implements ITarefaService {
    private ITarefaRepository repositorio;
    private IValidadorTarefa validador;
    private TarefaCacheRepository cacheRepository;

    public boolean cadastrar(String titulo, String descricao, LocalDate deadline, int prioridade, Usuario usuario) {
        if (!validador.validarTitulo(titulo)) return false;
        try {
            Tarefa novaTarefa = new Tarefa(titulo.trim(), descricao.trim(), LocalDate.now(), deadline, prioridade);
            novaTarefa.setUsuario(usuario);
            
            // 1. Persist√™ncia Real (SQL)
            repositorio.salvar(novaTarefa);
            
            // 2. Atualiza Mem√≥ria RAM (para a tela ver imediatamente)
            usuario.getTarefas().add(novaTarefa);
            
            // 3. Invalida Redis (para for√ßar recarregamento no pr√≥ximo login)
            cacheRepository.invalidarCache(usuario.getEmail());
            System.out.println("[SYNC] Tarefa criada. Redis invalidado e mem√≥ria atualizada.");
            
            return true;
        } catch (Exception ex) {
            ex.printStackTrace();
            return false;
        }
    }
}
</code></pre>

    <h4>C√≥digo novo:</h4>
    <h5>Service Factory:</h5>
    <pre><code>public class ServiceFactory {
    public static ITarefaService criarTarefaService() {
        // 1. Cria os componentes crus
        ITarefaRepository sqlRepo = new TarefaRepository();
        TarefaCacheRepository redisRepo = new TarefaCacheRepository();

        // 2. Envolve o SQL com o Proxy de Cache
        ITarefaRepository repoComCache = new TarefaRepositoryProxy(sqlRepo, redisRepo);

        IValidadorTarefa validador = new ValidadorTarefa();

        // 3. Entrega o Proxy para o Service (O Service nem sabe que existe cache!)
        return new TarefaService(repoComCache, validador);
</code></pre>
    <h5>Tarefa Repository Proxy:</h5>
    <pre><code>public class TarefaRepositoryProxy implements ITarefaRepository {

    private final ITarefaRepository repositorioReal; // O Banco SQL (TarefaRepository)
    private final TarefaCacheRepository cache;       // O Cache Redis

    // Injetamos as duas depend√™ncias via construtor
    public TarefaRepositoryProxy(ITarefaRepository real, TarefaCacheRepository cache) {
        this.repositorioReal = real;
        this.cache = cache;
    }

    public List&lt;Tarefa&gt; listarPorUsuario(Usuario usuario) {
        // 1. Tenta pegar do Cache (R√°pido)
        List&lt;Tarefa&gt; tarefasCache = cache.buscarCache(usuario.getId());
        
        if (tarefasCache != null) {
            System.out.println("[PROXY] Cache HIT - Retornando do Redis.");
            return tarefasCache;
        }
        // 2. Se n√£o achar, pega do Banco Real (Lento)
        System.out.println("[PROXY] Cache MISS - Buscando no SQL...");
        List&lt;Tarefa&gt; tarefasSQL = repositorioReal.listarPorUsuario(usuario);

        // 3. Salva no Cache para a pr√≥xima vez
        if (tarefasSQL != null) {
            cache.salvarCache(usuario.getId(), tarefasSQL);
        }
        return tarefasSQL;
    }
    public void salvar(Tarefa tarefa) {
        // Salva no banco real
        repositorioReal.salvar(tarefa);
        // Invalida o cache do usu√°rio, pois a lista mudou
        cache.invalidarCache(tarefa.getUsuario().getId());
    }
    public void remover(Tarefa tarefa) {
        repositorioReal.remover(tarefa);
        cache.invalidarCache(tarefa.getUsuario().getId());
    }
    public void atualizar(Tarefa antiga, Tarefa nova) {
        repositorioReal.atualizar(antiga, nova);
        cache.invalidarCache(antiga.getUsuario().getId());
    }
}
</code></pre>

    <h5>Tarefa Service:</h5>
    <pre><code>public class TarefaService implements ITarefaService, ISubject {

    // O Reposit√≥rio aqui ser√°, em tempo de execu√ß√£o, o TarefaRepositoryProxy
    private ITarefaRepository repositorio;
    private IValidadorTarefa validador;

    public boolean excluir(String titulo, Usuario usuario) {
        try {
            // Busca segura
            Tarefa tarefa = buscarPorTitulo(titulo, usuario);
            if (tarefa != null) {
                // O Proxy intercepta, remove do SQL e invalida o cache
                repositorio.remover(tarefa);
                return true;
            }
            return false;
        } catch (Exception ex) {
            ex.printStackTrace();
            return false;
        }
    }    
}
</code></pre>

    <hr>

    <h3>üèóÔ∏è 4.6. Builder (Constru√ß√£o Fluente)</h3>

    <ul>
        <li><strong>Problema:</strong> A entidade <code>Tarefa</code> tinha muitos atributos opcionais, levando a
            construtores confusos com muitos par√¢metros nulos opcionais.</li>
        <li><strong>Solu√ß√£o:</strong> <code>TarefaBuilder</code> permite cria√ß√£o passo-a-passo, al√©m de constru√ß√µes
            personalizadas.</li>
    </ul>

    <h4>C√≥digo antigo :</h4>
    <pre><code>public class TarefaService {
    // cria√ß√£o de tarefa nova
    public boolean cadastrar(String titulo, String descricao, LocalDate deadline, int prioridade) {
        // valida√ß√£o da exist√™ncia do t√≠tulo
        if(titulo == null || titulo.trim().equals("")) { // sem espa√ßo no if
            return false; // t√≠tulo obrigat√≥rio
        }
        try {
            // instancia√ß√£o da tarefa com data atual
            Tarefa novaTarefa = new Tarefa(titulo.trim(), descricao.trim(), LocalDate.now(), deadline, prioridade);
        ...}
    }
}       
</code></pre>

    <h4>C√≥digo novo:</h4>
    <h5>Builder:</h5>
    <pre><code>public class TarefaBuilder {
    private String titulo;
    private String descricao;
    private LocalDate dataCadastro;
    private LocalDate deadline;
    private int prioridade;
    private double percentual;

    public TarefaBuilder() {
        // Valores padr√£o
        this.dataCadastro = LocalDate.now();
        this.percentual = 0.0;
        this.prioridade = 1; // Prioridade m√≠nima padr√£o
        this.descricao = "";
    }

    public TarefaBuilder comTitulo(String titulo) {
        this.titulo = titulo != null ? titulo.trim() : null;
        return this;
    }

    public TarefaBuilder comDescricao(String descricao) {
        this.descricao = descricao != null ? descricao.trim() : "";
        return this;
    }
    ...

    public Tarefa construir() {
        if (titulo == null || titulo.isEmpty()) {
            throw new IllegalStateException("T√≠tulo da tarefa √© obrigat√≥rio.");
        }
        if (deadline == null) {
            throw new IllegalStateException("Data limite (Deadline) √© obrigat√≥ria.");
        }
        Tarefa tarefa = new Tarefa(titulo, descricao, dataCadastro, deadline, prioridade);
        tarefa.setPercentual(percentual);
        return tarefa;
    }
}
</code></pre>

    <h5>Tarefa Service:</h5>
    <pre><code>public class TarefaService implements ITarefaService, ISubject {
   public boolean cadastrar(String titulo, String descricao, LocalDate deadline, int prioridade, Usuario usuario) {
        // 1. Valida√ß√£o preliminar
        if (!validador.validarTitulo(titulo)) {
            return false;
        }
        try {
            // 2. Constru√ß√£o do Objeto
            Tarefa novaTarefa = new TarefaBuilder()
                    .comTitulo(titulo)
                    .comDescricao(descricao)
                    .comPrazo(deadline)
                    .comPrioridade(prioridade)
                    .construir();
             ...
        }
   }
}            
</code></pre>

    <h3>üëë 4.7. Singleton (Inst√¢ncia √önica)</h3>

    <ul>
        <li><strong>Problema:</strong> Criar m√∫ltiplas inst√¢ncias da <code>EntityManagerFactory</code> do Hibernate
            consome muita mem√≥ria e pools de conex√£o.</li>
        <li><strong>Solu√ß√£o:</strong> O <code>DatabaseManager</code> garante uma √∫nica inst√¢ncia global sendo
            reaproveitada durante todo o ciclo de vida do app.</li>
        <li><strong>C√≥digo:</strong></li>
    </ul>

    <pre><code>public class DatabaseManager {
    private static DatabaseManager instance;
    private EntityManagerFactory emf;

    private DatabaseManager() {
        try {
            this.emf = Persistence.createEntityManagerFactory("todoListPU");
        } catch (Exception e) {
            System.err.println("FATAL: Erro ao conectar no Banco SQL (Porta 5433, 5432).");
            e.printStackTrace();
            throw new RuntimeException(e);
        }
    }

    public static synchronized DatabaseManager getInstance() {
        if (instance == null)
            instance = new DatabaseManager();
        return instance;
    }

    public EntityManager getEntityManager() {
        return emf.createEntityManager();
    }

    public void close() {
        if (emf != null)
            emf.close();
    }
}
</code></pre>

    <hr>

    <h2>5. Conclus√£o</h2>

    <h3>5.1. A Curva de Aprendizado</h3>
    <p>O projeto foi uma jornada de transforma√ß√£o no nosso entendimento sobre desenvolvimento de software.</p>
    <p>A an√°lise do c√≥digo legado (<code>fc7ce99</code>) revela como decis√µes iniciais e amadoras focadas em "fazer
        funcionar" criaram um grande d√©bito. A persist√™ncia bin√°ria, por exemplo, impedia mudan√ßas no modelo, a classe
        <code>ManipuladorDeTarefas</code> e <code>ToDoList</code> centralizava regras de neg√≥cio, persist√™ncia e at√©
        parsing de strings, tornando imposs√≠vel a escalabilidade/extensibilidade e testes isolados.
    </p>
    <p>A arquitetura final v2.0, com a quebra dessas classes monol√≠ticas em Services e Repositories, transformou o
        projeto em uma base s√≥lida, test√°vel e pronta para escalar.</p>

    <h3>5.2. O Desafio da Refatora√ß√£o</h3>
    <p>Refatorar o sistema foi consideravelmente mais dif√≠cil do que escrev√™-lo do zero. Desacoplar a persist√™ncia
        bin√°ria para injetar o JPA foi um processo doloroso, pois a l√≥gica de UI estava misturada com regras de neg√≥cio.
        Tivemos que "trocar o motor com o carro andando". A maior li√ß√£o foi: <strong>c√≥digo mal projetado cobra juros
            altos</strong>. Cada atalho que foi tomado na v1.0 nos custou horas de depura√ß√£o na v2.0.</p>

    <h3>5.3. O Resultado</h3>
    <p>Hoje, temos orgulho do c√≥digo que produzimos. O sistema n√£o apenas funciona, mas √© elegante. A aplica√ß√£o de
        padr√µes n√£o foram apenas para cumprir requisistos, mas resolveu problemas reais que o c√≥digo tinha, al√©m de
        permitir a extensibilidade.</p>
    <p>O aprendizado e o uso de estruturas na pr√°tica como <code>Simple Factory</code>, <code>Repository</code> ,
        <code>Controller</code> e <code>Services</code> podem ser replicadas em qualquer aplica√ß√£o futura, acredito que
        demos um passo importante na carreira de programadores, nos tornamos mais capazes de criar sistemas que
        sobrevivam ao tempo.
    </p>

</body>

</html>