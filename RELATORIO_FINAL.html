<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Relat√≥rio Final - Projeto ToDoList</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,300;0,400;0,500;0,700;1,400&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;500&display=swap');

        body {
            font-family: 'Roboto', sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 800px;
            margin: 0 auto;
            padding: 40px;
            background-color: #fff;
        }

        h1,
        h2,
        h3,
        h4,
        h5 {
            color: #2c3e50;
            margin-top: 1.5em;
            margin-bottom: 0.5em;
        }

        h1 {
            font-size: 2.5em;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }

        h2 {
            font-size: 1.8em;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
        }

        h3 {
            font-size: 1.4em;
            color: #34495e;
        }

        h4 {
            font-size: 1.2em;
            color: #555;
            font-weight: 600;
        }

        h5 {
            font-size: 1.0em;
            color: #666;
            font-weight: 600;
            margin-top: 1em;
        }

        p {
            margin-bottom: 1em;
            text-align: justify;
        }

        ul {
            margin-bottom: 1em;
        }

        code {
            font-family: 'Fira Code', monospace;
            background-color: #f8f9fa;
            padding: 2px 5px;
            border-radius: 4px;
            font-size: 0.9em;
            color: #e10a0a;
        }

        pre {
            background-color: #f6f8fa;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            border: 1px solid #e1e4e8;
            margin-bottom: 1.5em;
        }

        pre code {
            background-color: transparent;
            color: #24292e;
            padding: 0;
            font-size: 0.85em;
        }

        blockquote {
            border-left: 4px solid #3498db;
            margin: 1.5em 0;
            padding-left: 15px;
            color: #555;
            background-color: #f9f9f9;
            padding: 10px 15px;
            border-radius: 0 5px 5px 0;
        }

        hr {
            border: 0;
            height: 1px;
            background: #eee;
            margin: 2em 0;
        }

        @media print {
            body {
                padding: 0;
                max-width: 100%;
            }

            h1 {
                page-break-before: always;
            }

            h1:first-of-type {
                page-break-before: auto;
            }

            pre {
                white-space: pre-wrap;
                word-wrap: break-word;
            }

            a {
                text-decoration: none;
                color: #000;
            }
        }
    </style>
</head>

<body>

    <h1>üìÑ Relat√≥rio Final de Arquitetura e Desenvolvimento: ToDoList 2.0</h1>
    <p><strong>Disciplina:</strong> Padr√µes de Projeto <br>
        <strong>Projeto:</strong> Sistema de Gerenciamento de Tarefas (ToDoList) <br>
        <strong>Data:</strong> 10/12/2025 <br>
        <strong>Equipe:</strong> Joseph Nichollas Abreu Cavalcante, Herbert Carvalho dos Santos
    </p>
    <hr>

    <h2>1. Introdu√ß√£o</h2>
    <p>Este relat√≥rio documenta a evolu√ß√£o arquitetural do projeto ToDoList, detalhando a transi√ß√£o de sua vers√£o legada
        (v1.0) para a atual (v2.0). A an√°lise baseia-se na compara√ß√£o direta entre o c√≥digo original (commit
        <code>fc7ce99</code>) e o estado atual, focando nas decis√µes de design iniciais, suas consequ√™ncias negativas e
        as refatora√ß√µes aplicadas para garantir escalabilidade e qualidade.
    </p>
    <hr>

    <h2>2. Decis√µes de Design "Question√°veis" (An√°lise do Legado v1.0)</h2>
    <p>Ao revisar o c√≥digo-fonte da primeira vers√£o entregue (<code>fc7ce99</code>), identificamos padr√µes que limitavam
        severamente a evolu√ß√£o do software.</p>

    <h3>‚ùå 2.1. A Serializa√ß√£o Monol√≠tica (<code>controle.ManipuladorDeTarefas</code>)</h3>
    <ul>
        <li><strong>A Decis√£o:</strong> A classe <code>ManipuladorDeTarefas</code> implementava
            <code>Serializable</code> e guardava todas as tarefas em uma <code>ArrayList</code> em mem√≥ria. Para
            persistir, grav√°vamos o objeto inteiro.
        </li>
        <li><strong>O C√≥digo Legado (v1.0):</strong></li>
    </ul>
    <pre><code>// controle/ManipuladorDeTarefas.java
public class ManipuladorDeTarefas implements Serializable {
    private List&lt;Tarefa&gt; listaTarefas;

    public void cadastrarTarefa(String titulo, String descricao, String deadlineStr, int prioridade) throws Exception {
            try {
                // convers√£o DD/MM/AAAA para LocalDate
                String[] partesData = deadlineStr.split("/");
                int dia = Integer.parseInt(partesData[0]);
                int mes = Integer.parseInt(partesData[1]);
                int ano = Integer.parseInt(partesData[2]);
                
                LocalDate prazoFinal = LocalDate.of(ano, mes, dia);
                LocalDate dataAtual = LocalDate.now();
                
                Tarefa novaTarefa = new Tarefa(titulo, descricao, dataAtual, prazoFinal, prioridade);
                adicionarTarefa(novaTarefa);
            } catch (Exception erro) {
                throw new Exception("Data inv√°lida. Use o formato DD/MM/AAAA");
            }
        }
    
    public List&lt;Tarefa&gt; listarTarefasCriticas() {
        LocalDate dataAtual = LocalDate.now();
        return listaTarefas.stream()
            .filter(tarefa -&gt; tarefa.getDeadline().minusDays(tarefa.getPrioridade()).isBefore(dataAtual))
            .collect(Collectors.toList());
    }
}</code></pre>
    <ul>
        <li><strong>Por que foi ruim:</strong>
            <ul>
                <li><strong>Mon√≥lito de Dados:</strong> Se tiv√©ssemos 1 milh√£o de tarefas, precis√°vamos carregar 1
                    milh√£o de objetos na RAM para editar um √∫nico t√≠tulo.</li>
                <li><strong>Viola√ß√£o de SRP:</strong> A classe sabia gerenciar a lista, filtrar dados e at√© fazer
                    parsing de String para Data (<code>DD/MM/AAAA</code>).</li>
                <li><strong>Fragilidade de Vers√£o:</strong> Como a classe implementava <code>Serializable</code>,
                    qualquer mudan√ßa no c√≥digo (ex: mudar nome de vari√°vel) impedia a leitura dos arquivos salvos
                    anteriormente.</li>
            </ul>
        </li>
    </ul>

    <h3>‚ùå 2.2. A "God Class" (<code>controle.ToDoList</code>) com Estado Global</h3>
    <ul>
        <li><strong>A Decis√£o:</strong> A classe <code>ToDoList</code> acumulava responsabilidades de Controller, Facade
            e Persist√™ncia. Pior ainda, ela mantinha o estado da aplica√ß√£o (<code>usuarioAtual</code> e
            <code>gerenciadorTarefas</code>) em mem√≥ria.
        </li>
        <li><strong>O C√≥digo Legado (v1.0):</strong></li>
    </ul>
    <pre><code>public class ToDoList {
    private ManipuladorDeTarefas gerenciadorTarefas;
    private Persistencia salvaDados;
    private Usuario usuarioAtual;
    private TarefaService serviceTarefas;
    private SubtarefaService serviceSubs;
    private static final String ARQUIVO_DADOS = "todolist.dat"; // arquivo onde salva

    // construtor - inicializa tudo
    public ToDoList() {
        this.gerenciadorTarefas = new ManipuladorDeTarefas();
        this.salvaDados = new Persistencia();
        this.usuarioAtual = new Usuario("Usu√°rio", "projetopoo00@gmail.com"); // email fixo
        
        // tenta carregar dados salvos
        carregarDados();
        
        // cria os services
        this.serviceTarefas = new TarefaService(gerenciadorTarefas);
        this.serviceSubs = new SubtarefaService(gerenciadorTarefas, serviceTarefas);
    }

    // carrega os dados do arquivo
    private void carregarDados() {
        try {
            ManipuladorDeTarefas dadosCarregados = salvaDados.carregarManipulador(ARQUIVO_DADOS);
            if (dadosCarregados != null) {
                this.gerenciadorTarefas = dadosCarregados; // substitui o vazio
                // se tem usuario salvo, usa ele
                if (dadosCarregados.getUsuario() != null) {
                    this.usuarioAtual = dadosCarregados.getUsuario();
                }
            }
        } catch (Exception erro) {
            System.out.println("Arquivo de dados n√£o encontrado. Iniciando com dados vazios.");
        }
}</code></pre>
    <ul>
        <li><strong>Por que foi ruim:</strong>
            <ul>
                <li><strong>Acoplamento Temporal e de Sess√£o:</strong> A inst√¢ncia de <code>ToDoList</code> "sabia" quem
                    estava logado. Passar essa inst√¢ncia de uma tela para outra significava carregar todo o estado da
                    sess√£o junto. Se o sistema reiniciasse, o login era perdido instantaneamente.</li>
                <li><strong>Acoplamento por Instancia√ß√£o Concreta:</strong> A classe violava o princ√≠pio de Invers√£o de
                    Depend√™ncia (DIP) ao instanciar manualmente suas depend√™ncias com <code>new</code>.</li>
            </ul>
        </li>
    </ul>

    <h3>‚ùå 2.3. Persist√™ncia Bin√°ria Fr√°gil (<code>persistencia.Persistencia</code>)</h3>
    <ul>
        <li><strong>A Decis√£o:</strong> A classe <code>Persistencia</code> encapsulava a escrita direta de objetos Java
            em disco.</li>
        <li><strong>O C√≥digo Legado (v1.0):</strong></li>
    </ul>
    <pre><code>public class Persistencia {

    // grava√ß√£o do manipulador em arquivo
    public void salvarManipulador(ManipuladorDeTarefas manipulador, String nomeArquivo) {
        try (ObjectOutputStream gravador = new ObjectOutputStream(new FileOutputStream(nomeArquivo))) {
            gravador.writeObject(manipulador);
        } catch (IOException erro) {
            erro.printStackTrace();
        }
    }

    // carregamento do manipulador do arquivo
    public ManipuladorDeTarefas carregarManipulador(String nomeArquivo) {
        try (ObjectInputStream leitor = new ObjectInputStream(new FileInputStream(nomeArquivo))) {
            return (ManipuladorDeTarefas) leitor.readObject();
        } catch (IOException | ClassNotFoundException ex) {
            return null; // arquivo inexistente ou corrompido
        }
    }
} </code></pre>
    <ul>
        <li><strong>Por que foi ruim:</strong>
            <ul>
                <li><strong>Fragilidade Extrema:</strong> Qualquer altera√ß√£o simples nas classes <code>Tarefa</code> ou
                    <code>Usuario</code> alterava o <code>serialVersionUID</code>, causando
                    <code>InvalidClassException</code>.
                </li>
                <li><strong>Escalabilidade Zero:</strong> Ler e gravar o arquivo inteiro a cada
                    <code>adicionarTarefa()</code> causava lentid√£o exponencial.
                </li>
            </ul>
        </li>
    </ul>
    <hr>

    <h2>3. Refatora√ß√µes e Bons Princ√≠pios (Clean Core & SOLID)</h2>
    <p>A vers√£o 2.0 foi reescrita focando em desacoplamento e estabilidade.</p>

    <h3>‚úÖ 3.1. Invers√£o de Controle e Persist√™ncia Poliglota</h3>
    <p>Abandonamos o arquivo bin√°rio e adotamos JPA (Hibernate).</p>
    <ul>
        <li><strong>Refatora√ß√£o:</strong> Substitu√≠mos o m√©todo <code>salvarDados()</code> direto na
            <code>ToDoList</code> por Reposit√≥rios injetados.
        </li>
        <li><strong>Impacto Positivo:</strong>
            <ul>
                <li><strong>Independ√™ncia de Dados:</strong> O <code>TarefaService</code> agora apenas chama
                    <code>repositorio.salvar(tarefa)</code>.
                </li>
                <li><strong>Seguran√ßa de Dados:</strong> Alterar a classe <code>Tarefa</code> n√£o corrompe o banco, pois
                    o Hibernate gerencia a migra√ß√£o do Schema.</li>
            </ul>
        </li>
    </ul>
    <h4>C√≥digo Antes (Legado):</h4>
    <pre><code>// ToDoList.java v1.0
public void removerTarefa(Tarefa tarefa) {
    gerenciadorTarefas.removerTarefa(tarefa);
    salvarDados(); // Grava√ß√£o em arquivo for√ßada
}</code></pre>
    <h4>C√≥digo Depois (v2.0):</h4>
    <pre><code>// TarefaService.java v2.0
public boolean excluir(String titulo, Usuario usuario) {
    Tarefa tarefa = buscarPorTitulo(titulo, usuario);
    if (tarefa != null) {
        repositorio.remover(tarefa); // Delega para o banco SQL
        return true;
    }
    return false;
}</code></pre>

    <h3>‚úÖ 3.2. Segrega√ß√£o de Valida√ß√£o (SRP)</h3>
    <p>Retiramos regras de valida√ß√£o de dentro do Controller/View e criamos classes especialistas.</p>

    <h3>‚úÖ 3.3. Centraliza√ß√£o da Cria√ß√£o (Simple Factory)</h3>
    <p>Utilizamos uma Factory para isolar a complexidade de instanciar objetos e suas depend√™ncias.</p>
    <pre><code>public static ITarefaService criarTarefaService() {
    // 1. Cria os componentes crus
    ITarefaRepository sqlRepo = new TarefaRepository();
    TarefaCacheRepository redisRepo = new TarefaCacheRepository();

    // 2. Envolve o SQL com o Proxy de Cache
    ITarefaRepository repoComCache = new TarefaRepositoryProxy(sqlRepo, redisRepo);

    IValidadorTarefa validador = new ValidadorTarefa();

    // 3. Entrega o Proxy para o Service (O Service nem sabe que existe cache!)
    return new TarefaService(repoComCache, validador);
}</code></pre>

    <h3>‚úÖ 3.4. Segrega√ß√£o de Interface (ISP)</h3>
    <p>Dividimos interfaces gigantes em menores e espec√≠ficas (<code>ITarefaService</code>,
        <code>ISubtarefaService</code>).
    </p>
    <hr>

    <h2>4. Aplica√ß√£o de Padr√µes de Projeto (GoF)</h2>
    <p>Design Patterns foram aplicados onde havia dor real no desenvolvimento.</p>

    <h3>üß© 4.1. Template Method (Relat√≥rios)</h3>
    <ul>
        <li><strong>Motiva√ß√£o:</strong> No commit <code>947d12e</code>, o <code>GeradorDeRelatorios</code> duplicava a
            l√≥gica de abrir/fechar streams para PDF e CSV.</li>
        <li><strong>Solu√ß√£o:</strong> <code>RelatorioTemplate</code> define o fluxo <code>final gerarRelatorio()</code>.
        </li>
    </ul>

    <h4>C√≥digo Antes (1.0):</h4>
    <pre><code>public class GeradorDeRelatorios {
    
    // gera√ß√£o de relat√≥rio PDF di√°rio
    public static void gerarRelatorioPDF(List&lt;Tarefa&gt; tarefas, LocalDate data) {
        Document documentoPDF = new Document();
        try {
            // configura√ß√£o do arquivo PDF
            PdfWriter.getInstance(documentoPDF, new FileOutputStream("relatorio.pdf"));
            documentoPDF.open();
            documentoPDF.add(new Paragraph("Relat√≥rio de Tarefas do dia: " + data));

            // verifica√ß√£o de exist√™ncia de tarefas
            if (tarefas.isEmpty()) {
                documentoPDF.add(new Paragraph("Nenhuma tarefa encontrada para este dia."));
            } else {
                // itera√ß√£o sobre as tarefas
                for (Tarefa item : tarefas) {
                    documentoPDF.add(new Paragraph("T√≠tulo: " + item.getTitulo()));
                    documentoPDF.add(new Paragraph("Descri√ß√£o: " + item.getDescricao()));
                }
            }
        } catch (DocumentException | IOException erro) {
            erro.printStackTrace();
        } finally {
            documentoPDF.close();
        }
    }

    // cria√ß√£o de planilha Excel (formato CSV)
    public static void gerarRelatorioExcel(List&lt;Tarefa&gt; tarefas, int mes, int ano) {
        // implementa√ß√£o simples usando CSV duplica logica de abrir/fechar
        try (FileOutputStream arquivoSaida = new FileOutputStream("relatorio_mensal.csv")) {
            // ...
        } catch (IOException erro) {
            erro.printStackTrace();
        }
    }
} </code></pre>

    <h4>C√≥digo Depois (Padr√£o Aplicado):</h4>
    <h5>Gerador De Relatorios</h5>
    <pre><code>public class GeradorDeRelatorios implements IRelatorioService {

    @Override
    public boolean gerarPDF(List&lt;Tarefa&gt; tarefas, LocalDate data) {
        RelatorioTemplate relatorio = new RelatorioPDF(data);
        return relatorio.gerarRelatorio(tarefas, "relatorio.pdf");
    }</code></pre>
    <h5>Relatorio Template</h5>
    <pre><code>public abstract class RelatorioTemplate {
    public final boolean gerarRelatorio(List&lt;Tarefa&gt; tarefas, String caminhoArquivo) {
        try {
            abrirArquivo(caminhoArquivo);
            escreverCabecalho();
            if (tarefas.isEmpty()) {
                escreverCorpoVazio();
            } else {
                for (Tarefa tarefa : tarefas) {
                    escreverTarefa(tarefa);
                }
            }
            escreverRodape();
            fecharArquivo();
            return true;
        } catch (Exception e) {
            tratarErro(e);
            return false;
        }
    }

    // Hooks 
    protected abstract void abrirArquivo(String caminho) throws Exception;
    protected abstract void escreverCabecalho() throws Exception;
    protected abstract void escreverTarefa(Tarefa tarefa) throws Exception;
    protected abstract void fecharArquivo() throws Exception;
}</code></pre>

    <h3>üö¶ 4.2. Strategy (Estrat√©gias de Filtro e Ordena√ß√£o)</h3>
    <ul>
        <li><strong>Motiva√ß√£o:</strong> M√©todos r√≠gidos como <code>listarTarefasPorData</code> e
            <code>listarTarefasCriticas</code>.
        </li>
        <li><strong>Solu√ß√£o:</strong> Interface <code>IFiltroStrategy</code>.</li>
    </ul>

    <h4>C√≥digo Antes (Legado):</h4>
    <pre><code>public class ManipuladorDeTarefas implements Serializable {
    public List&lt;Tarefa&gt; listarTarefasPorData(LocalDate data) {
        return listaTarefas.stream()
                .filter(tarefa -&gt; tarefa.getDeadline().equals(data))
                .collect(Collectors.toList());
    }
}</code></pre>

    <h4>C√≥digo Depois (Strategy):</h4>
    <h5>Interface Filtro:</h5>
    <pre><code>public interface IFiltroStrategy {
    List&lt;Tarefa&gt; filtrar(List&lt;Tarefa&gt; tarefas);
}</code></pre>
    <h5>Filtro por Data:</h5>
    <pre><code>public class FiltroPorDataStrategy implements IFiltroStrategy {
    private final LocalDate dataAlvo;

    public FiltroPorDataStrategy(LocalDate dataAlvo) {
        this.dataAlvo = dataAlvo;
    }

    public List&lt;Tarefa&gt; filtrar(List&lt;Tarefa&gt; tarefas) {
        if (dataAlvo == null) return tarefas;
        return tarefas.stream()
                .filter(t -&gt; t.getDeadline().equals(dataAlvo))
                .collect(Collectors.toList());
    }
}</code></pre>

    <h3>üèØ 4.3. Facade (ToDoList Refatorado)</h3>
    <ul>
        <li><strong>Problema:</strong> <code>ToDoList</code> antiga era uma God Class com estado e regras.</li>
        <li><strong>Solu√ß√£o:</strong> Nova <code>ToDoList</code> √© uma Fachada pura.</li>
    </ul>

    <h4>v1.0 (God Class):</h4>
    <pre><code>public class ToDoList {
    private ManipuladorDeTarefas gerenciadorTarefas;
    private Persistencia salvaDados;
    // ... estado global ...
    
    public ToDoList() {
        this.gerenciadorTarefas = new ManipuladorDeTarefas();
        // ... new Persistencia() ...
    }
}</code></pre>
    <h4>v2.0 Facade:</h4>
    <pre><code>public class ToDoList {
    // N√£o tem estado. Apenas encaminha pro controller
    public boolean login(String email, String senha) {
        return usuarioController.login(email, senha);
    }
    public Usuario obterUsuario() {
        return usuarioController.obterUsuario();
    }
}</code></pre>

    <h3>üì° 4.4. Observer (Notifica√ß√µes)</h3>
    <ul>
        <li><strong>Problema:</strong> Notificar a UI quando uma tarefa muda.</li>
        <li><strong>Solu√ß√£o:</strong> O <code>TarefaService</code> notifica observadores.</li>
    </ul>

    <h4>C√≥digo:</h4>
    <h5>Subject Concreto (Tarefa Service):</h5>
    <pre><code>public class TarefaService implements ITarefaService, ISubject {
    private List&lt;interfaces.observer.IObserver&gt; observadores = new ArrayList&lt;&gt;();

    public void notificarObservadores(Object mensagem) {
        for (interfaces.observer.IObserver observer : observadores) {
            observer.atualizar(mensagem);
        }
    }
    public void atualizarPercentual(Long idTarefa, double novoPercentual) {
        // ... atualiza ...
        notificarObservadores("Tarefa atualizada: " + tarefa.getTitulo());
    }    
}</code></pre>
    <h5>Observer Concreto (TelaListarTarefas):</h5>
    <pre><code>public class TelaListarTarefas extends JPanel implements IObserver {
    public void atualizar(Object mensagem) {
        SwingUtilities.invokeLater(() -&gt; {
            carregarTarefas(this.dataFiltro);
        });
    }
}</code></pre>

    <h3>üõ°Ô∏è 4.5. Proxy (Cache Transparente)</h3>
    <ul>
        <li><strong>Problema:</strong> Cache no Service sujaria a regra de neg√≥cio.</li>
        <li><strong>Solu√ß√£o:</strong> <code>TarefaRepositoryProxy</code> intercepta.</li>
    </ul>

    <h4>C√≥digo novo:</h4>
    <h5>Proxy:</h5>
    <pre><code>public class TarefaRepositoryProxy implements ITarefaRepository {

    private final ITarefaRepository repositorioReal; // SQL
    private final TarefaCacheRepository cache;       // Redis

    public TarefaRepositoryProxy(ITarefaRepository real, TarefaCacheRepository cache) {
        this.repositorioReal = real;
        this.cache = cache;
    }

    public List&lt;Tarefa&gt; listarPorUsuario(Usuario usuario) {
        // 1. Tenta pegar do Cache (R√°pido)
        List&lt;Tarefa&gt; tarefasCache = cache.buscarCache(usuario.getId());
        if (tarefasCache != null) return tarefasCache;

        // 2. Se n√£o achar, pega do Banco Real (Lento)
        List&lt;Tarefa&gt; tarefasSQL = repositorioReal.listarPorUsuario(usuario);

        // 3. Salva no Cache para a pr√≥xima vez
        if (tarefasSQL != null) cache.salvarCache(usuario.getId(), tarefasSQL);
        
        return tarefasSQL;
    }
}</code></pre>

    <h3>üèóÔ∏è 4.6. Builder (Constru√ß√£o Fluente)</h3>
    <ul>
        <li><strong>Problema:</strong> Construtores com muitos par√¢metros nulos.</li>
        <li><strong>Solu√ß√£o:</strong> <code>TarefaBuilder</code>.</li>
    </ul>

    <h4>C√≥digo novo:</h4>
    <h5>Builder:</h5>
    <pre><code>public class TarefaBuilder {
    // ... atributos ...
    public TarefaBuilder comTitulo(String titulo) {
        this.titulo = titulo;
        return this;
    }
    public Tarefa construir() {
        if (titulo == null) throw new IllegalStateException("T√≠tulo obrigat√≥rio");
        return new Tarefa(titulo, descricao, ...);
    }
}</code></pre>
    <h5>Uso no Service:</h5>
    <pre><code>Tarefa novaTarefa = new TarefaBuilder()
        .comTitulo(titulo)
        .comDescricao(descricao)
        .comPrazo(deadline)
        .comPrioridade(prioridade)
        .construir();</code></pre>

    <h3>üëë 4.7. Singleton (Inst√¢ncia √önica)</h3>
    <ul>
        <li><strong>Problema:</strong> M√∫ltiplas inst√¢ncias de <code>EntityManagerFactory</code>.</li>
        <li><strong>Solu√ß√£o:</strong> <code>DatabaseManager</code>.</li>
    </ul>
    <pre><code>public class DatabaseManager {
    private static DatabaseManager instance;

    private DatabaseManager() {
        // ... inicializa EMF ...
    }

    public static synchronized DatabaseManager getInstance() {
        if (instance == null) instance = new DatabaseManager();
        return instance;
    }
}</code></pre>

    <hr>

    <h2>5. Conclus√£o e Li√ß√µes Aprendidas</h2>
    <p>Este projeto representou muito mais do que apenas uma entrega acad√™mica; foi uma jornada de transforma√ß√£o no
        nosso entendimento sobre desenvolvimento de software.</p>

    <h3>5.1. A Curva de Aprendizado</h3>
    <p>No in√≠cio (v1.0), nossa inexperi√™ncia com Orienta√ß√£o a Objetos "de verdade" era evidente. Criamos uma classe Deus
        porque parecia mais f√°cil centralizar tudo. Acredit√°vamos que "mais classes" significava "mais complexidade",
        quando na verdade descobrimos o oposto: classes pequenas e coesas simplificam a manuten√ß√£o.</p>

    <h3>5.2. O Desafio da Refatora√ß√£o</h3>
    <p>Refatorar o sistema foi consideravelmente mais dif√≠cil do que escrev√™-lo do zero. Desacoplar a persist√™ncia
        bin√°ria para injetar o JPA foi um processo doloroso, pois a l√≥gica de UI estava misturada com regras de neg√≥cio.
        Tivemos que "trocar o motor com o carro andando". A maior li√ß√£o foi: <strong>c√≥digo mal projetado cobra juros
            altos</strong>.</p>

    <h3>5.3. O Resultado</h3>
    <p>Hoje, temos orgulho do c√≥digo que produzimos. O sistema n√£o apenas funciona, mas √© elegante. A aplica√ß√£o de
        padr√µes como <strong>Observer</strong> e <strong>Proxy</strong> resolveu problemas reais.</p>

    <h3>5.4. Pr√≥ximos Passos</h3>
    <p>Este reposit√≥rio agora serve como uma base s√≥lida (Template Repository) para nossos projetos futuros. Sa√≠mos
        desta disciplina n√£o apenas como programadores, mas como engenheiros de software.</p>

</body>

</html>